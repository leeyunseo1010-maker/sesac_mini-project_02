import json
import math
from collections import defaultdict
from langchain_core.documents import Document
import re

def is_valid(val):
    """값이 유효한지(None, NaN, 빈 문자열 아님) 엄격하게 확인"""
    if val is None: 
        return False
    if isinstance(val, float) and math.isnan(val): 
        return False
    if isinstance(val, str) and (val.strip() == "" or val.strip().lower() == "nan"): 
        return False
    return True

def to_int_safe(x):
    """랭킹을 '파손 없이' 안전하게 int 변환 시도(실패 시 None)"""
    try:
        # "12", 12, 12.0 같은 케이스 대응
        if isinstance(x, bool):
            return None
        if isinstance(x, (int,)):
            return int(x)
        if isinstance(x, float):
            if math.isnan(x):
                return None
            return int(x)
        if isinstance(x, str):
            s = x.strip()
            if s == "" or s.lower() == "nan":
                return None
            # "12위" 같은 문자열도 숫자만 뽑아 시도(원본은 따로 보관)
            m = re.search(r"\d+", s)
            return int(m.group()) if m else None
    except:
        return None
    return None

path = "./data/rag_chunks_with_rankings.jsonl"
consolidated = {}

with open(path, "r", encoding="utf-8") as f:
    for line in f:
        clean_line = line.replace(": NaN", ": null").replace(": nan", ": null")
        try:
            data = json.loads(clean_line)
        except:
            continue

        name = data.get("card_name")
        comp = data.get("company")
        if not name or not comp:
            continue

        card_id = f"{name}_{comp}"

        # ✅ [추가] 랭킹 저장 구조 포함
        if card_id not in consolidated:
            consolidated[card_id] = {
                "card_name": name,
                "company": comp,
                "annual_fee": None,
                "performance": None,
                "url": None,
                "benefits": set(),

                # ---- ranking fields (원본 보존 중심) ----
                "rank_best_num": None,              # 가장 좋은(최소) 랭킹 숫자
                "rank_best_raw": None,              # 그때의 원본(raw) 값(문자열)
                "rank_raw_set": set(),              # 관측된 모든 원본 랭킹 값(파손 방지)
                "rank_by_category_raw": {},         # 카테고리별 첫 관측 raw 랭킹(덮어쓰기 방지)
            }

        card = consolidated[card_id]

        # ✅ [추가] 랭킹 추출/통합 (원본 파손 방지 + 최소랭킹 산출)
        r = data.get("rank")
        if is_valid(r):
            raw = str(r).strip()
            if raw:
                card["rank_raw_set"].add(raw)

                # 카테고리별 raw 저장(이미 있으면 덮어쓰지 않음)
                cat = data.get("category_norm", "기타")
                if is_valid(cat):
                    cat = str(cat).strip() or "기타"
                else:
                    cat = "기타"
                if cat not in card["rank_by_category_raw"]:
                    card["rank_by_category_raw"][cat] = raw

                # best rank 계산(숫자 변환 가능할 때만)
                r_num = to_int_safe(r)
                if r_num is not None:
                    if (card["rank_best_num"] is None) or (r_num < card["rank_best_num"]):
                        card["rank_best_num"] = r_num
                        card["rank_best_raw"] = raw

        # 3. 상세페이지 URL (이미 있으면 덮어쓰지 않음)
        current_url = data.get("detail_url")
        if is_valid(current_url) and not is_valid(card["url"]):
            card["url"] = current_url.strip()

        # 4. 연회비 (metrics 우선)
        metrics = data.get("metrics", {})
        if not is_valid(card["annual_fee"]):
            o_fee = metrics.get("fee_overseas_won")
            d_fee = metrics.get("fee_domestic_won")
            if is_valid(o_fee):
                card["annual_fee"] = f"해외 {int(o_fee):,}원"
            elif is_valid(d_fee):
                card["annual_fee"] = f"국내 {int(d_fee):,}원"

        # 5. 전월실적 (conditions 우선)
        if not is_valid(card["performance"]):
            p_won = data.get("conditions", {}).get("prev_month_won")
            if is_valid(p_won):
                card["performance"] = f"{int(p_won):,}원 이상"

        # 6. 혜택 정보 통합
        text_val = data.get("text", "")
        if "혜택 상세:" in text_val:
            benefit_detail = text_val.split("혜택 상세:")[1].split("|")[0].strip()
            category = data.get("category_norm", "기타")
            card["benefits"].add(f"[{category}] {benefit_detail}")

# 7. Document 객체로 변환 (✅ 랭킹을 컨텍스트에 포함)
docs = []
for info in consolidated.values():
    # best rank 표시: 숫자(best)가 있으면 그걸 우선, 없으면 raw 중 하나라도 있으면 raw 기반으로 표기
    if info["rank_best_num"] is not None:
        rank_text = f"{info['rank_best_num']}위"
    elif len(info["rank_raw_set"]) > 0:
        # raw가 여러 개면 그대로 모두 보관되어 있으니, 컨텍스트에는 합쳐서 노출
        rank_text = " / ".join(sorted(info["rank_raw_set"])) + " (원본)"
    else:
        rank_text = "확인 필요"

    # 카테고리별 랭킹(원본 그대로)도 함께 제공(원하면 프롬프트에서 활용 가능)
    if info["rank_by_category_raw"]:
        by_cat = ", ".join([f"{k}:{v}" for k, v in sorted(info["rank_by_category_raw"].items())])
    else:
        by_cat = "확인 필요"

    content = (
        f"카드명: {info['card_name']} ({info['company']})\n"
        f"카드고릴라랭킹: {rank_text}\n"
        f"카테고리별랭킹(원본): {by_cat}\n"
        f"연회비: {info['annual_fee'] if is_valid(info['annual_fee']) else '확인 필요'}\n"
        f"전월실적: {info['performance'] if is_valid(info['performance']) else '확인 필요'}\n"
        f"전체혜택:\n- " + "\n- ".join(sorted(list(info['benefits']))) + "\n"
        f"상세페이지: {info['url'] if is_valid(info['url']) else '확인 필요'}"
    )
    docs.append(Document(page_content=content))


embedding = OpenAIEmbeddings(model="text-embedding-3-small")

# vectorstore = Chroma.from_documents(
#     documents=docs,
#     embedding=embedding,
#     persist_directory="./Chroma",
#     collection_name="cardGorilla8"
# )
# vectorstore.persist()

vectorstore = Chroma(
    embedding_function=embedding,
    persist_directory="./Chroma",
    collection_name="cardGorilla8"
)

user_prompt = """\
아래 사용자의 정보를 보고 그 상황에 맞는 알맞은 카드를 추천해주세요.

[사용자 정보]
{input_data}

[카드 정보]
{context}\
"""



retriever = vectorstore.as_retriever(
    search_type="mmr",
    search_kwargs={
        "k": 50,
        "fetch_k": 500,
        "lambda_mult": 0.6
    }
)
result1 = retriever.invoke(input_data1)
result2 = retriever.invoke(input_data2)
result3 = retriever.invoke(input_data3)
result4 = retriever.invoke(input_data4)
result5 = retriever.invoke(input_data5)


rag_system_prompt = """\
<System_Prompt>
    <Role_Assignment>
        You are "Korean Credit Card Recommendation Chatbot". You MUST provide exactly 4 suitable card recommendations to the user in a single response, strictly based on the provided <context> data and the information in the <user_prompt>.
    </Role_Assignment>

    <Core_Directives>
    1. No Questions: DO NOT ask questions, counter-questions, or request clarification from user under any circumstances.
    2. RAG-Based Recommendation: ONLY select cards that exist within <context>. NEVER hallucinate or invent non-existent cards. Use ONLY the information provided in the <context>.
    3. Output ALL Benefits: You MUST extract and list ALL card benefits mentioned in <context>. Do not summarize them into just one benefit.
    4. Exclude Invalid Cards (Strict): NEVER recommend card if its benefit details are missing, or if it ONLY contains ranking information in <context>. A valid recommendation MUST contain actual card benefits.
    5. Internal CoT (Chain of Thought): Before generating final card recommendations, you MUST process user request internally using <Thinking_Process> block.
        - Step 1 (Keyword Extraction): Extract keywords from user's input (Preferred/Excluded card companies, Annual fee limits, Previous month performance constraints, Target benefit categories, or etc.).
        - Step 2 (Filtering): Filter out cards that lack benefit information. Then match remaining cards with keywords.
        - Step 3 (Selection): Select top 4 most appropriate cards that match the criteria.
    6. Strict Output Format: You MUST exactly follow <Output_Format> structure. DO NOT output greetings, introductions, summaries, or disclaimers outside of the specified blocks.
    7. Exact Card Count: You MUST output exactly 4 cards. Neither more nor less.
    8. Recommendation Reason Rules:
        - Provide recommendation reasons as numbered list (1, 2, 3...) with MAXIMUM of 5 items.
        - You MUST utilize ranking info if it exists in <context> and include it as one of the reasons (e.g., "이 카드는 최근 YYYY년 MM월 기준 카드고릴라 랭킹 X위이며, 월간 Top100에 총 X회 진입한 검증된 인기 카드입니다.").
        - DO NOT use exaggerated expressions (e.g., "무조건", "최고", "절대").
    9. Factual Accuracy: If annual fee, previous month performance (전월실적), benefits, or URL in <context> is unclear or missing, **strictly write "확인 필요" for that specific field**.
    10. Tone and Language: Strictly use polite Korean, ending sentences with "~니다" form. DO NOT contain English in responses.
    </Core_Directives>

    <Output_Format>
    <Thinking_Process>
    - 사용자 키워드 추출: [선호 카드사: ...], [전월실적 조건: ...], [연회비 조건: ...], [주요 혜택: ...] 등
    - <context> 필터링 및 추천: [선정된 4가지 카드 이름과 매칭 이유 간략히]
    </Thinking_Process>
    [카드 1]
    카드사: ...
    카드이름: ...
    연회비: ...
    전월실적: ...
    카드혜택: 
    - [혜택 분야] 혜택 상세
    - [혜택 분야] 혜택 상세
    ... (컨텍스트 내 모든 카드 혜택 나열, 각 혜택 마다 개행 후 나열) ...
    상세페이지: ...
    추천이유:
    1. ... (반드시 랭킹 정보 포함하면서 기준 날짜도 함께 포함)
    2. ...
    3. ...
    4. ...
    5. ...
    (최대 5가지 항목으로 작성)
    ====================
    [카드 2]
    ... (위와 동일 구조) ...
    ====================
    [카드 3]
    ... (위와 동일 구조) ...
    ====================
    [카드 4]
    ... (위와 동일 구조) ...
    </Output_Format>

    <Few_Shot_Examples>
    <Example>
        <User_Query> "20대 취준생입니다. 매일 대중교통으로 학원에 가고 편의점을 자주 가요. 전월실적이 30만원 이하로 낮았으면 좋겠고, 신한카드나 삼성카드를 선호합니다."</User_Query>
        <AI_Response>
            <Thinking_Process>
            - 사용자 키워드 추출: [주요 혜택: 대중교통, 편의점], [전월실적 조건: 30만원 이하], [선호 카드사: 신한카드, 삼성카드]
            - 컨텍스트 필터링 및 카드 선정:
              1. 신한카드 Mr.Life: 편의점 혜택 존재, 실적 30만원, 신한카드 충족 (랭킹 1위)
              2. 삼성카드 taptap O: 대중교통/편의점 혜택 존재, 실적 30만원, 삼성카드 충족 (랭킹 5위)
              3. 신한카드 Deep Dream: 전월실적 조건 없음, 편의점 적립, 신한카드 충족 (랭킹 12위)
              4. 삼성 iD SELECT ALL 카드: 편의점 혜택, 삼성카드 충족 (랭킹 2위)
            </Thinking_Process>

            [카드 1]
            카드사: 신한카드
            카드이름: 신한카드 Mr.Life
            연회비: 해외겸용 15,000 원
            전월실적: 30만 원 이상
            카드혜택:
            - [마트/편의점] 편의점 10% 할인
            - [의료/교육] 병원/약국 10% 할인
            - [공과금/보험 (생활)] 세탁소 10% 할인
            - [쇼핑 (온라인쇼핑)] 온라인쇼핑 10% 할인
            - [공과금/보험 (공과금)] 월납요금(공과금) 10% 할인서비스
            상세페이지: https://www.card-gorilla.com/card/detail/13
            추천이유:
            1. 2026년 2월 기준 카드고릴라 랭킹 1위를 차지할 만큼 많은 사람에게 검증된 인기 카드입니다.
            2. 편의점 결제 시 10% 할인을 제공하여 취업준비생의 식비 절감에 매우 유리합니다.
            3. 전월실적 조건이 30만 원으로 설정되어 있어 유지 부담이 적습니다.
            4. 통신요금 및 공과금 10% 할인이 포함되어 자취 고정비 방어에 탁월합니다.
            5. 사용자가 선호하는 신한카드사의 상품입니다.
            ====================
            [카드 2]
            카드사: 삼성카드
            카드이름: 삼성카드 taptap O
            연회비: 국내전용 10,000 원, 해외겸용 10,000 원
            전월실적: 30만 원 이상
            카드혜택:
            - [교통 (대중교통)] 대중교통/택시 10% 결제일할인
            - [문화/여가 (영화)] CGV 및 롯데시네마 5,000원 결제일할인
            - [통신 (통신)] 이동통신요금 10% 할인
            - [여행/항공/숙박 (해외)] 해외 1.3% 적립
            상세페이지: https://www.card-gorilla.com/card/detail/51
            추천이유:
            1. 2026년 2월 기준 카드고릴라 랭킹 6위에 올라 있는 선호도 최상위 카드입니다.
            2. 매일 이용하시는 대중교통 요금을 10% 할인받을 수 있어 통학 부담을 크게 덜어줍니다.
            3. 연회비가 1만 원으로 저렴하고 전월실적이 30만 원이라 관리가 수월합니다.
            4. 사용자가 선호하는 삼성카드사의 상품입니다.
            ====================
            [카드 3]
            카드사: 신한카드
            카드이름: 신한카드 처음(ANNIVERSE)
            연회비: 국내전용 15,000 원, 해외겸용 18,000 원
            전월실적: 30만 원 이상
            카드혜택:
            - [적립/캐시백 (적립)] 음식점·카페·편의점·온라인쇼핑 5% 마이신한포인트 적립
            - [공과금/보험 (생활)] 생활·여행·패션 5% 마이신한포인트 적립
            - [구독/디지털 (디지털구독)] 통신 10% , OTT 15%, 멤버십 20% 마이신한포인트 적립
            - [포인트/마일리지 적립] 소비관리 보너스(계획소비 & 즉시결제 적립)
            상세페이지: https://www.card-gorilla.com/card/detail/2759
            추천이유:
            1. 2026년 2월 기준 카드고릴라 랭킹 12위에 위치한 대표적인 적립형 카드입니다.
            2. 편의점, 온라인쇼핑 등 20대 대학생이 자주 소비하는 분야에서 5% 포인트 적립을 제공합니다.
            3. 소비관리 보너스(계획소비 적립, 즉시결제 적립) 혜택이 있어 범용성이 뛰어납니다.
            4. 사용자가 명시한 신한카드사의 상품입니다.
            ====================
            [카드 4]
            카드사: 삼성카드
            카드이름: 삼성 iD SELECT ALL 카드
            연회비: 국내 20,000 원, 해외 20,000 원
            전월실적: 40만원 이상
            카드혜택:
            - [적립/캐시백 (할인)] 아파트 관리비/통신 10% 할인
            - [적립/캐시백 (할인)] 편의점 7% 할인
            - [적립/캐시백 (할인)] 온라인쇼핑몰/의료/배달앱 7% 할인
            - [구독/디지털 (디지털구독)] 디지털콘텐츠 멤버십 50% 할인
            상세페이지: https://www.card-gorilla.com/card/detail/2885
            추천이유:
            1. 2026년 2월 기준 카드고릴라 랭킹 2위를 차지한 대세 카드입니다.
            2. 편의점 7% 할인을 비롯해 배달앱 할인까지 제공되어 식비 관리에 유리합니다.
            3. OTT 등 디지털 구독 50% 할인이 포함되어 있어 20대 라이프스타일에 부합합니다.
            4. 통신비 10% 할인을 통해 추가적인 고정지출 방어가 가능합니다.
            5. 선호하시는 삼성카드 라인업 중 최근 가장 트렌디한 혜택을 담고 있습니다.
        </AI_Response>
    </Example>
    </Few_Shot_Examples>
</System_Prompt>
"""

rag_template = ChatPromptTemplate([
    ("system", rag_system_prompt),
    ("user", user_prompt)
])

model = "gpt-5-nano"
model = ChatOpenAI(model=model, temperature=0.8)

rag_chain = rag_template | model | StrOutputParser()

def clean_output(text):
    return re.sub(r'<Thinking_Process>.*?</Thinking_Process>', '', text, flags=re.DOTALL).strip()

# [NEW] 5명의 데이터를 하나의 리스트로 묶기 (튜플 형태)
test_customers = [
    (input_data1, result1),
    (input_data2, result2),
    (input_data3, result3),
    (input_data4, result4),
    (input_data5, result5)
]

# [NEW] for문(반복문)을 사용해 한 번에 처리
for i, (user_input, ctx) in enumerate(test_customers, 1):
    print(f"{i}번째 고객\n{user_input}")
    
    # 모델 응답 생성
    raw_ans = rag_chain.invoke({"input_data": user_input, "context": ctx})
    
    # 정제 후 출력
    print("\n답변:\n", clean_output(raw_ans))
    print("\n" + "="*50 + "\n")